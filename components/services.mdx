---
title: Services
description: What is a service and when do you need one?
---

Services represent any containerized application that you want to run as part of your component. This
includes APIs, webapps, and even some cloud workers.

For anyone familiar with [Docker Compose](https://docs.docker.com/compose/), the syntax of a service
will look exceedingly familiar. The main difference is the usage of Architect's expression syntax to
refer to peer APIs and databases to power both local and remote environments.

```yaml architect.yml
services:
  api1:
    build:
      context: ./
    interfaces:
      main:
        port: 8080
  api2:
    image: my-docker-image:latest
    interfaces:
      main:
        port: 8080
    environment:
      API1_URL: ${{ services.api1.interfaces.main.url }}
```

## Building from source code

More often than not, you'll want to have Architect build the containers for your service to make it
easier to run local dev environments and to minimize manual steps you'd otherwise have to do yourself.

<Note>
  When building from source you do not need an `image` field. Architect will automatically build and
  publish the container to the same registry as the component and then replace the `build` block with
  the new `image` value before completing registration or deployment.
</Note>

```yaml architect.yml
services:
  api:
    build:
      context: ./path/to/source/code
```

### Custom Dockerfile name

By default, Architect will assume that you have a file named `Dockerfile` in the same directory cited in
the build `context` field. However, you can always override that to point to whatever filename you wish
with the `dockerfile` field.

```yaml architect.yml
services:
  api:
    build:
      context: ./
      dockerfile: Dockerfile.prod
```

### Using buildpack

<Warning>
  Buildpack support is currently an **alpha** feature. While the feature should be stable, it may be
  changed without prior notice.
</Warning>

Don't know how to build a Dockerfile? No problem! Architect is uses [Cloud Native Buildpacks](https://buildpacks.io/)
to automatically build containers directly from source code.

If a Dockerfile isn't found, Architect will automatically attempt to use a suitable buildpack to
produce a functional. If you DO have a Dockerfile but want to test out buildpack anyway, you can
turn it on manually with the `buildpack` flag.

```yaml architect.yml
services:
  api:
    build:
      context: ./
      buildpack: true
```

The version of the builder image is `heroku/buildpacks:20`. This builder version only supports
languages such as Java, Go, Node.js, PHP, Python, Ruby, Scala, and Typescript. Learn more about
[Heroku builder](https://github.com/heroku/builder).

Depending on the language that the application is written in, there might be some requirements in
order to build successfully. For example, if an application is written in Java, only these
[supported Java versions](https://devcenter.heroku.com/articles/java-support#supported-java-versions)
can be used. After selecting a Java version, a `system.properties` might be required at the root of
the application for the builder to use the correct [Java runtime version](https://devcenter.heroku.com/articles/java-support#specifying-a-java-version).

## Environment variables

One of the most common ways to configure cloud applications with unique runtime values is through
environment variables. Environment variables allow an application to receive input unique to the
environment its running in, and are often used for things like credentials and addresses for other
APIs and databases.

```yaml architect.yml
services:
  api:
    image: my-api:latest
    environment:
      DB_HOST: rds.amazonwebservices.com/....
      DB_USER: username
      DB_PASS: password
      DB_NAME: my-db
```

As you can see from the example above, some environment variable values are sensitive and you certainly don't
want them checked in to version control with your `architect.yml` file. For this reason, Architect allows
you to declare environment variables without hardcoding their values. This allows them to be enriched securely
whenever the component gets deployed to an environment.

```yaml architect.yml
services:
  api:
    image: my-api:latest
    environment:
      DB_HOST:
        description: Hostname of the APIs database
        required: true
      DB_USER:
        description: Username used to login to the database
        required: true
      DB_PASS:
        description: Password used to login to the database
        required: true
      DB_NAME:
        description: Name of the database the application stores content in
        default: my-db
```

Want to learn how to configure values for these variables? Head over to the [environment docs](/environments/)
and check out how to configure values for [local environments](/environments/local) and
[remote environments](/environments/remote) respectively.

## Integrating services

If you're working with multiple services, you'll probably want them to be able to talk to one another.
Frontends need to talk to backends, microservices need to make API calls to one another, etc. Architect
allows services to communicate with one another via `interfaces`.

### Exposing an interface

Declaring an interface for your application is the first step in making sure that other applications can
connect to it. The only required value for an interfaces is the `port` that the application listens on, and
everything else Architect can take care of for you.

```yaml architect.yml
services:
  api:
    image: my-api:latest
    interfaces:
      main:
        port: 8080
```

### Integrating with an interface

Now that you know how to declare a service interface, you're ready to connect to that interface from another
service. Architect makes this easy by letting you inject the interface address by reference so that the value
will be correct in every environment you deploy to. 

```yaml architect.yml
services:
  api:
    image: my-api:latest
    interfaces:
      main:
        port: 8080
  app:
    image: my-app:latest
    environment:
      API_ADDR: ${{ services.api.interfaces.main.url }}
```

Take note of the `API_ADDR` environment variable value. Any usage of `${{ ... }}` opening and closing braces
uses Architect's [expression syntax for Components](/components/expressions) to refer to values that won't be
known until the component is deployed.

In this case, the reference to `services.api` refers to the api service in our component, and `interfaces.main`
refers to it's main interface. From there, you can cite values like `host`, `port`, and `url`, and Architect
will inject the correct values every time the component gets deployed to a new environment.

## Local-only configuration

The nature of services is usually to be portable, reusable, and unchanging, but that's only true when you're
done coding. When you're actively working on your services, you often need to use specific tools, tactics, or
commands to facilitate hot-reloading that you don't need to use once you're feature complete.

For features like this, Architect services support a `debug` block. The `debug` block allows you to extend the
functionality of your service with details that will only be triggered when you run the `architect dev` command.

```yaml architect.yml
services:
  api:
    build:
      context: ./
    interfaces:
      main:
        port: 3000
    debug:
      command: npm run dev
      volumes:
        src:
          description: Mounts the src folder to the container so the application will refresh when I edit my code
          mount_path: /app/src
          host_path: ./src
```

Running `architect deploy` or `architect register` would ignore the configuration inside the `debug` block, but
running `architect dev` would merge the debug values in with the rest of the service configuration.

Want to learn how to setup hot-reloading for your component? We've got some great guides for a variety of languages.

[Learn more about hot-reloading](/guides/hot-reloading/overview)

## Volumes

## Configuration options

<Note>This field cannot be used in conjunction with the `build` field</Note>

#### Overriding service hosts

Architect supports overriding a service with the URL of an external host. When
this is done, the service will not be created by Architect, but all of the
interpolated values of the service will continue to be produced. This is a
common pattern in cases where a user wants Architect to manage everything for
local development, but wants to reference a managed service such as a database
instance for staging or production. For example, the service below represents a
Postgres database service that can be either managed by Architect or effectively
an external reference:

```yaml
---
secrets:
  postgres_host:
    required: false
---
services:
  api-db:
    image: postgres:11
    interfaces:
      postgres:
        host: ${{ secrets.postgres_host }}
        port: 5432
        protocol: postgresql
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: architect
      POSTGRES_DB: architect_postgres_db
```

The secret `postgres_host` will determine whether or not the service will be
provisioned by Architect. If `postgres_host` is not set, Architect will
provision the `api-db` service and create a `postgres:11` container. If the
`postgres_host` secret is set, `image: postgres:11` will be ignored and the
container will not be provisioned by Architect. Any interpolated values that
include the `api-db` service will produce the correct output in either instance
with the difference being that `${{ services.api-db.interfaces.postgres.host }}`
and `${{ services.api-db.interfaces.postgres.url }}` will change based on the
`host` of the interface. Note that if a service has multiple interfaces and you
would like to reference an external service, all of the Architect service's
interfaces must specify the `host` override.

### labels

Dictionary of string keys and values that can be used to organize and categorize
(scope and select) the service.

Syntax and character set Labels are key/value pairs. Valid label keys have two
segments: an optional prefix and name, separated by a slash (/). The name
segment is required and must be 63 characters or less, beginning and ending with
an alphanumeric character ([a-z0-9A-Z]) with dashes (-), underscores (\_), dots
(.), and alphanumerics between. The prefix is optional. If specified, the prefix
must be a DNS subdomain: a series of DNS labels separated by dots (.), not
longer than 63 characters in total, followed by a slash (/).

Valid label value: must be 63 characters or less (can be empty), unless empty,
must begin and end with an alphanumeric character ([a-z0-9A-Z]), could contain
dashes (-), underscores (\_), dots (.), and alphanumerics between.

### liveness_probe

This configuration is essentially the health check for the service. It's
important to specify so that traffic isn't load balanced to unhealthy services.
Critical for rolling updates to function properly.

```yaml
liveness_probe:
  # (required) Command that will be run to check application health
  command: curl --fail localhost:8080/health
  # (deprecated, optional) Port that the http check will run against
  port: 8080
  # (deprecated, optional) Path for the http check
  path: /health
  # (optional, defaults to 0s) Delays the check from running for the specified amount of time
  initial_delay: 0s
  # (optional, defaults to 30s) The time period in seconds between each health check execution. You may specify between 5 and 300 seconds.
  interval: 30s
  # (optional, defaults to 5s) The time period in seconds to wait for a health check to succeed before it is considered a failure. You may specify between 2 and 60 seconds.
  timeout: 5s
  # (optional, defaults to 1) The number of times to retry a health check before the container is considered healthy.
  success_threshold: 1
  # (optional, defaults to 1) The number of times to retry a failed health check before the container is considered unhealthy. You may specify between 1 and 10 retries.
  failure_threshold: 1
```

### volumes

(optional) A dictionary containing a set of named volumes that the service will
request and mount to each service instance. Architect can take advantage of
volumes to store data that should be shared between running containers or that
should persist beyond the lifetime of a container.

#### Local configuration

If you would like to use the local filesystem as a volume or a `docker-compose`
volume, use the options below in the **debug** block of your service:

```yaml
volumes:
  my-volume-name:
    # Directory at which the volume will be mounted inside the container
    mount_path: /usr/app/images

    # (optional) Human-readable description of volume
    description: Description of my volume

    # (optional) A directory on the host machine to sync with the mount_path on the docker image.
    # This is primarily used for local debugging
    host_path: ./relative/to/architect.yml

    # (optional) The name of a `docker-compose` volume that has already been created on the host machine.
    key: my-compose-volume-name
```

#### Kubernetes

Kubernetes persistent volume claims can be created in advance of a deployment
requiring volumes. Be sure to create the claim(s) in the same namespace that the
services will be created in. An example of a persistent volume configuration
that can be applied to a cluster namespace is below:

```yaml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: my-claim
  namespace: my-namespace
spec:
  storageClass: "" # Set this to a storage class that supports the access modes below
  accessModes:
    - ReadWriteMany # The default PVC storage class must support this access mode
    - ReadOnlyMany # The default PVC storage class must support this access mode
  resources:
    requests:
      storage: 5Gi
```

In order to use the persistent volume above in a service, include a block of the
type below:

```yaml
---
volumes:
  my-volume:
    # Directory at which the volume will be mounted inside the container
    mount_path: /usr/app/images

    # Name of the persistent volume claim that has been created in the Kubernetes cluster
    key: my-claim
```

Architect deployments to Kubernetes clusters also support dynamic volume
provisioning. If an Architect service contains a volume that does not specify a
`key` property, the volume will be created automatically at deploy time. An
example of such a volume is below. Be sure that the Kubernetes cluster's default
storage class includes both the `ReadWriteOnce` and `ReadOnlyMany` access modes
and that the volume binding mode is set to `Immediate`.

```yaml
---
volumes:
  my-volume:
    # Directory at which the volume will be mounted inside the container
    mount_path: /usr/app/images
```

### cpu & memory

`cpu`: a whole number or decimal that represents the vCPUs allocated to the
service when it runs.

```yaml
cpu: 1
```

`memory`: a string that represents the memory allocated to the service when it
runs.

```yaml
memory: 2GB
```

### depends_on

`depends_on` takes an array of references to other services within the
component. These dictate startup order: at deployment time, services will not be
started until any of their listed dependents have already started.

```yaml
services:
  app: # here, app will not start until my-api and db have started
    depends_on:
      - my-api
      - db
    interfaces:
      postgres: 5432
  my-api: # here, my-api will not start until db has started
    depends_on:
      - db
    interfaces:
      admin: 8081
  db:
    interfaces:
      postgres: 5432
```

### replicas

(optional) The number of replicas the service should have when it's deployed.
This number will apply across environments unless overridden by an
[environment-specific setting](/deployments/scaling/#scale-command).

```yaml
replicas: 4
```

## Local development

When developing your service locally you may want to mount volumes or alter the
command that is used in remote environments. Learn more about how to specify
with [local configuration](/components/local-configuration).
