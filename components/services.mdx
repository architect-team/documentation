---
title: Services
description: What is a service and when do you need one?
---

Services represent any containerized application that you want to run as part of your component. This
includes APIs, webapps, and even some cloud workers.

For anyone familiar with [Docker Compose](https://docs.docker.com/compose/), the syntax of a service
will look exceedingly familiar. The main difference is the usage of Architect's expression syntax to
refer to peer APIs and databases to power both local and remote environments.

```yaml architect.yml
services:
  api1:
    build:
      context: ./
    interfaces:
      main:
        port: 8080
  api2:
    image: my-docker-image:latest
    interfaces:
      main:
        port: 8080
    environment:
      API1_URL: ${{ services.api1.interfaces.main.url }}
```

## Building from source code

More often than not, you'll want to have Architect build the containers for your service to make it
easier to run local dev environments and to minimize manual steps you'd otherwise have to do yourself.

<Note>
  When building from source you do not need an `image` field. Architect will automatically build and
  publish the container to the same registry as the component and then replace the `build` block with
  the new `image` value before completing registration or deployment.
</Note>

```yaml architect.yml
services:
  api:
    build:
      context: ./path/to/source/code
```

### Custom Dockerfile name

By default, Architect will assume that you have a file named `Dockerfile` in the same directory cited in
the build `context` field. However, you can always override that to point to whatever filename you wish
with the `dockerfile` field.

```yaml architect.yml
services:
  api:
    build:
      context: ./
      dockerfile: Dockerfile.prod
```

### Using buildpack

<Warning>
  Buildpack support is currently an **alpha** feature. While the feature should be stable, it may be
  changed without prior notice.
</Warning>

Don't know how to build a Dockerfile? No problem! Architect is uses [Cloud Native Buildpacks](https://buildpacks.io/)
to automatically build containers directly from source code.

If a Dockerfile isn't found, Architect will automatically attempt to use a suitable buildpack to
produce a functional. If you DO have a Dockerfile but want to test out buildpack anyway, you can
turn it on manually with the `buildpack` flag.

```yaml architect.yml
services:
  api:
    build:
      context: ./
      buildpack: true
```

The version of the builder image is `heroku/buildpacks:20`. This builder version only supports
languages such as Java, Go, Node.js, PHP, Python, Ruby, Scala, and Typescript. Learn more about
[Heroku builder](https://github.com/heroku/builder).

Depending on the language that the application is written in, there might be some requirements in
order to build successfully. For example, if an application is written in Java, only these
[supported Java versions](https://devcenter.heroku.com/articles/java-support#supported-java-versions)
can be used. After selecting a Java version, a `system.properties` might be required at the root of
the application for the builder to use the correct [Java runtime version](https://devcenter.heroku.com/articles/java-support#specifying-a-java-version).

## Environment variables

One of the most common ways to configure cloud applications with unique runtime values is through
environment variables. Environment variables allow an application to receive input unique to the
environment its running in, and are often used for things like credentials and addresses for other
APIs and databases.

```yaml architect.yml
services:
  api:
    image: my-api:latest
    environment:
      DB_HOST: rds.amazonwebservices.com/....
      DB_USER: username
      DB_PASS: password
      DB_NAME: my-db
```

As you can see from the example above, some environment variable values are sensitive and you certainly don't
want them checked in to version control with your `architect.yml` file. For this reason, Architect allows
you to declare environment variables without hardcoding their values. This allows them to be enriched securely
whenever the component gets deployed to an environment.

```yaml architect.yml
services:
  api:
    image: my-api:latest
    environment:
      DB_HOST:
        description: Hostname of the APIs database
        required: true
      DB_USER:
        description: Username used to login to the database
        required: true
      DB_PASS:
        description: Password used to login to the database
        required: true
      DB_NAME:
        description: Name of the database the application stores content in
        default: my-db
```

Want to learn how to configure values for these variables? Head over to the [environment docs](/environments/)
and check out how to configure values for [local environments](/environments/local) and
[remote environments](/environments/remote) respectively.

## Integrating services

If you're working with multiple services, you'll probably want them to be able to talk to one another.
Frontends need to talk to backends, microservices need to make API calls to one another, etc. Architect
allows services to communicate with one another via `interfaces`.

### Exposing an interface

Declaring an interface for your application is the first step in making sure that other applications can
connect to it. The only required value for an interfaces is the `port` that the application listens on, and
everything else Architect can take care of for you.

```yaml architect.yml
services:
  api:
    image: my-api:latest
    interfaces:
      main:
        port: 8080
```

### Integrating with an interface

Now that you know how to declare a service interface, you're ready to connect to that interface from another
service. Architect makes this easy by letting you inject the interface address by reference so that the value
will be correct in every environment you deploy to. 

```yaml architect.yml
services:
  api:
    image: my-api:latest
    interfaces:
      main:
        port: 8080
  app:
    image: my-app:latest
    environment:
      API_ADDR: ${{ services.api.interfaces.main.url }}
```

Take note of the `API_ADDR` environment variable value. Any usage of `${{ ... }}` opening and closing braces
uses Architect's [expression syntax for Components](/components/expressions) to refer to values that won't be
known until the component is deployed.

In this case, the reference to `services.api` refers to the api service in our component, and `interfaces.main`
refers to it's main interface. From there, you can cite values like `host`, `port`, and `url`, and Architect
will inject the correct values every time the component gets deployed to a new environment.

## Exposing services

Application-to-application communication is crucial, but at the end of the day you'll likely need at least one
application (usually a frontend) exposed publicly so that end-users can reach it. Architect makes this easy
for developers by simply enabling ingress for a service interface:

```yaml architect.yml
services:
  api:
    image: my-frontend:latest
    interfaces:
      main:
        port: 8080
        ingress:
          subdomain: app
          path: /path
```

If you deployed a component with the service configuration above, the URL `https://app.<environment-base-url>/path` would
become available via the environment's API gateway and would forward traffic to your service.

## Volumes

On-disk files in a container are ephemeral which means that by default your application loses all disk data when it crashes
or otherwise restarts. Volumes represent disk space that lives outside of the container runtime that gets mounted to the
container when it starts up. By using external volumes, your data will remain in-tact in the event your service crashes or
restarts.

```yaml architect.yml
services:
  api:
    image: my-api:latest
    volumes:
      cache:
        description: Volume containing some cached data to speed up API responses
        mount_path: /app/cache
```

## Local configuration

The nature of services is usually to be portable, reusable, and unchanging, but that's only true when you're
done coding. When you're actively working on your services, you often need to use specific tools, tactics, or
commands to facilitate hot-reloading that you don't need to use once you're feature complete.

For features like this, Architect services support a `debug` block. The `debug` block allows you to extend the
functionality of your service with details that will only be triggered when you run the `architect dev` command.

```yaml architect.yml
services:
  api:
    build:
      context: ./
    interfaces:
      main:
        port: 3000
    debug:
      command: npm run dev
      volumes:
        src:
          description: Mounts the src folder to the container so the application will refresh when I edit my code
          mount_path: /app/src
          host_path: ./src
```

Running `architect deploy` or `architect register` would ignore the configuration inside the `debug` block, but
running `architect dev` would merge the debug values in with the rest of the service configuration.

Want to learn how to setup hot-reloading for your component? We've got some great guides for a variety of languages.

[Learn more about hot-reloading](/guides/hot-reloading/overview)

## Production readiness

Even though you can run your app locally, there are still a few extra features you can take advantage of to better
prepare your services for production. You're still the expert when it comes to your application, so you've got
to do your part to help out anyone who might run your application to do so in a safe and cost-effective way.

### Liveness probes

Liveness probes are scripts that get run that to test whether or not your application has booted up completely and
remains healthy. These scripts are often run by container platforms to detect if services are unhealthy so they can
attempt to restart them automatically or route traffic to other instances.

```yaml architect.yml
services:
  main:
    liveness_prove:
      # (required) Command that will be run to check application health
      command: curl --fail localhost:8080/healthz

      # (optional, defaults to 0s) Delays the check from running for the
      # specified amount of time
      initial_delay: 0s

      # (optional, defaults to 30s) The time period in seconds between
      # each health check execution. You may specify between 5 and 300 seconds.
      interval: 30s

      # (optional, defaults to 5s) The time period in seconds to wait for a
      # health check to succeed before it is considered a failure. You may specify
      # between 2 and 60 seconds.
      timeout: 5s

      # (optional, defaults to 1) The number of times to retry a health check before
      # the container is considered healthy.
      success_threshold: 1

      # (optional, defaults to 1) The number of times to retry a failed health check
      # before the container is considered unhealthy. You may specify between 1 and 10 retries.
      failure_threshold: 1
```

### CPU & Memory

The `cpu` and `memory` fields on a component tell container platforms and environment operators
how many resources are needed by a single instance of your service. Providing accurate resource
usage numbers helps operators ensure that costs of each environment are kept low.

```yaml architect.yml
services:
  main:
    # (optional) a whole number or decimal that represents the number of vCPUs allocated
    # to each service instance
    cpu: 1

    # (optional) a string representation of the amount of memory to allocate to each
    # instance of the service. 
    memory: 2GB
```

### Auto-scaling

Even though the number of replicas to run is an environment-specific decision (e.g. one replica in
preview environments, but several in production), you can help out the operations teams greatly by
codifying your services with the most reasonable metrics to use to trigger auto-scaling.

The scaling metrics below allow you to specify upper thresholds for CPU and memory usage that should
be used to trigger scale-up events and create more replicas of your service. 

```yaml architect.yml
services:
  main:
    cpu: 1
    memory: 2GB
    scaling:
      metrics:
        # (optional) a number from 1-100 representing a percentage of memory utilization
        memory: 80

        # (optional) a nmber from 1-100 representing a percentage of cpu utilization
        cpu: 70
```