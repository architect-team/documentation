---
title: Component specification
sidebarTitle: Reference
description: Raw details on the available configuration options for a component
---

## Component spec

Components described using this syntax can leverage the CLI and Kubernetes
cluster to provision and update production-grade environments on-demand or via
automation.

### metadata

<ResponseField name="name" required type="string">
  Unique name of the component used by others to cite it as a dependency. Component names must
  be unique within an Architect account.
</ResponseField>

<ResponseField name="description" type="string">
  A human-readable description of the component so others know when they should use it
</ResponseField>

<ResponseField name="keywords" type="string | string[]">
  Additional search terms to be used when the component is indexed so others can find it more
  easily.
</ResponseField>

### services

A dictionary of named runtimes for the component. Each service described in an
`architect.yml` file will be automatically deployed to your Kubernetes cluster
and registered with your service mesh and API gateway as needed.

```yaml
services:
  my-api:
    ## Instructions on how to build the docker image for this service
    #
    # cannot be used in conjunction with the `image` property
    build:
      context: ./path/to/docker/build/context
      dockerfile: ./relative/to/context/Dockerfile
      target: build
      args:
        key: value
    
    ## Docker image to use for the service
    # 
    # Cannot be used in conjunction with the `build` property
    image: nginx:latest

    # Entrypoint to use instead of the one from the docker image
    entrypoint: npm

    # Command to use at startup instead of the one in the docker image
    command: start

    # Environment variables to inject into the service
    environment:
      # Values can be populated explicitly
      DB_ADDR: rds.amazonwebservices.com/db-name

      # Values can be populated via Architect expressions
      DB_USER: ${{ secrets.db-user }}

      # Variables can declare how the value should be configured by environments
      DB_PASS:
        required: true
        description: Password used to authenticate with the database
        default: password
    
    # Listeners the service responds to
    interfaces:
      # Interfaces can use the shorthand if they only care about the port
      public: 8080

      # Interfaces can be longform if they need to specify more details
      admin:
        port: 8081

        # Ingress configuration exposes the interface outside the environment via the API gateway
        ingress:
          enabled: true
          subdomain: auth
          path: /api
    
    # Labels to add to the generated cloud resources
    labels:
      architect.io/environment: dev
      architect.io/service: api
    
    # Liveness probe to run to determine service health and readiness
    liveness_probe:
      # Command that will be run to check application health
      # @required
      command: curl --fail localhost:8080/health
      
      # Delays the check from running for the specified amount of time
      # @default 0s
      initial_delay: 0s

      # The time period in seconds between each health check execution. You may specify between 5 and 300 seconds.
      # @default 30s
      interval: 30s

      # The time period in seconds to wait for a health check to succeed before it is considered a failure. 
      # You may specify between 2 and 60 seconds.
      # @default 5s
      timeout: 5s

      # The number of times to retry a health check before the container is considered healthy.
      # @default 1
      success_threshold: 1

      # The number of times to retry a failed health check before the container is considered unhealthy.
      # You may specify between 1 and 10 retries.
      # @default 1
      failure_threshold: 1
    
    # Number of replicas of the service to deploy by default
    # @default 1
    replicas: 2

    # Amount of CPU to allocate per replica
    cpu: 1

    # Amount of memory to allocate per replica
    memory: 512mb

    # Configuration overrides to be used only by the `architect dev` command
    debug:
      command: npm run dev
      volumes:
        src:
          host_path: ./src/
          mount_path: /usr/app/src/
```

### dependencies

A set of other components that must be deployed into the same environment as this one. The keys of
the dictionary are the names of the components that should be deployed, and the value (for now) is
just an empty object.

```yaml
dependencies:
  auth: {}
  payments: {}
```

### tasks

A set of named, containerized jobs to be run on a schedule. Tasks support all the same features as
[services](#services) except for `interfaces`.

```yaml
tasks:
  my-task:
    schedule: 0 3 * * 0
    build:
      context: .
    command: node run-reports.js
    environment:
      KEY: value
```

### secrets

(optional) A dictionary of named, configurable fields for the component. Each
secret can include a description so that others know what to assign for values,
a default value for when deployers don't specify one, and an indication as to
whether or not a value is required.

```yaml
secrets:
  my-secret:
    default: default-value
    required: false
    description: Human-readable description
```

| key           | description             |
| ------------- | ----------------------- |
| `default`     | Value to output |
| `description` | (optional) Description of when to use the output |
| `required`    | Boolean indicating whether or not a user must provide a value (default: false) |

### outputs

(optional) A dictionary of named fields that the component is making available to upstream consumers.
Each output must include a value and can optionally include a description indicating when it should
be used.

```yaml
outputs:
  user-signup-topic:
    description: Published to when a new user signs up
    value: topic-name
```

| key           | description             |
| ------------- | ----------------------- |
| `value`       | Value to output |
| `description` | (optional) Description of when to use the output |

## Expression options

In addition to the raw anatomy of the components, the specification also supports several different
ways to use dynamic values to automate or simply component configuration.

### secrets

Secrets are synonymous with component inputs. They allow you to declare values that should be injected
into the application at deploy time to be used in one or more places withou the component spec.

```yaml
secrets:
  secret-name:
    description: My secret

services:
  api:
    environment:
      SECRET_VALUE: ${{ secrets.secret-name }}
```

### services.\*.interfaces

Interfaces represent listeners for services, and other apps and services often need to refer to one another
when making API calls to each other.

```yaml
services:
  api:
    interfaces:
      main:
        port: 8080
    environment:
      SELF_ADDR: ${{ services.api.interfaces.main.url }}
```

| key        | description |
| ---------- | ----------- |
| `url`      | Fully resolvable URL of the interface |
| `host`     | Hostname of the interface |
| `port`     | Port the interface is exposed on |
| `protocol` | Protocol the interface responds to |

### services.\*.interfaces.\*.ingress

In addition to the internal addresses, interfaces can optionally be configured to support external addresses
as well. Applications can then inject the external address into their own configuration by refering to the 
ingress portion of the interface.

```yaml
services:
  api:
    interfaces:
      main:
        port: 8080
        ingress:
          enabled: true
    environment:
      SELF_ADDR: ${{ services.api.interfaces.main.ingress.url }}
```

| key        | description |
| ---------- | ----------- |
| `url`      | Fully resolvable URL of the ingress |
| `host`     | Hostname of the ingress |
| `port`     | Port the ingress is exposed on |
| `protocol` | Protocol the ingress responds to |

### databases

Like services, databases represent persistent runtimes that can be connected to by other applications and
services. You can refer to many of the same fields supported by service interfaces for databases as well.

```yaml
databases:
  main:
    type: postgres:13

services:
  api:
    interfaces:
      main:
        port: 8080
    environment:
      DB_DSN: ${{ databases.main.url }}
```

| key        | description |
| ---------- | ----------- |
| `url`      | Fully resolvable URL of the database (aliases: `dsn`, `connection_string`) |
| `host`     | Hostname of the database |
| `port`     | Port the database is exposed on |
| `protocol` | Protocol the database responds to |
| `username` | Username used to authenticate with the database |
| `password` | Password used to authenticate with the database |
| `database` | The database (e.g. namespace) on the instance to be connected to |

### dependencies

Dependencies refer to other components that the current one wants to guarantee exist in the
same environment. Once declared, components can then inject references to any of the resources
inside that component into their own configuration.

```yaml
dependencies:
  auth: {}

services:
  api:
    interfaces:
      main:
        port: 8080
    environment:
      AUTH_ADDR: ${{ dependencies.auth.services.api.interfaces.main.url }}
      USER_SIGNUP_TOPIC: ${{ dependencies.auth.outputs.user-signup-topic }}
```

| key        | description |
| ---------- | ----------- |
| `services` | References to individual services inside the dependency (see [services](#services-interfaces)) |
| `outputs`  | Values output by the downstream component to be used by consumers |